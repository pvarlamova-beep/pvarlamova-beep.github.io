<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Classic Tetris</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #0d1117;
            color: #c9d1d9;
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
        }
        .game-container {
            box-shadow: 0 0 20px rgba(240, 246, 252, 0.1), 0 0 40px rgba(240, 246, 252, 0.1);
            border: 3px solid #30363d;
        }
        canvas {
            background-color: #010409;
            border: 2px solid #21262d;
        }
        .touch-button {
            transition: all 0.1s ease;
            user-select: none; /* Prevents text selection on repeated tapping */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .touch-button:active {
            transform: scale(0.95);
            background-color: #30363d;
        }
        .modal {
            display: flex;
            justify-content: center;
            align-items: center;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            text-align: center;
        }
        .modal-content {
             background-color: #161b22;
             padding: 2rem;
             border-radius: 1rem;
             border: 2px solid #30363d;
             box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">

    <div class="w-full max-w-4xl mx-auto p-4">
        <h1 class="text-3xl md:text-4xl text-center mb-4 uppercase">Tetris</h1>
        <div class="flex flex-col md:flex-row justify-center gap-4">

            <!-- Game Board -->
            <div class="game-container bg-gray-900 p-2 md:p-4 rounded-lg">
                <canvas id="tetris" width="240" height="480"></canvas>
            </div>

            <!-- Game Info & Controls -->
            <div class="flex flex-col justify-between space-y-4 md:space-y-0">
                <div class="bg-gray-900/50 p-4 rounded-lg text-center md:text-left">
                    <h2 class="text-lg mb-2">SCORE</h2>
                    <p id="score" class="text-2xl">0</p>
                    <h2 class="text-lg mt-4 mb-2">LINES</h2>
                    <p id="lines" class="text-2xl">0</p>
                    <h2 class="text-lg mt-4 mb-2">LEVEL</h2>
                    <p id="level" class="text-2xl">1</p>
                </div>

                <div class="bg-gray-900/50 p-4 rounded-lg text-center">
                    <h2 class="text-lg mb-2">NEXT</h2>
                    <canvas id="next" width="96" height="96"></canvas>
                </div>
            </div>
        </div>

        <!-- Touch Controls -->
        <div class="mt-6 md:hidden">
            <div class="flex justify-center items-center gap-2 mb-2">
                <button id="rotate-btn" class="touch-button bg-gray-800 text-white rounded-full w-20 h-20 flex items-center justify-center border-2 border-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-arrow-clockwise" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>
                </button>
                <button id="drop-btn" class="touch-button bg-gray-800 text-white rounded-full w-20 h-20 flex items-center justify-center border-2 border-gray-700 text-sm font-bold">HARD<br>DROP</button>
            </div>
            <div class="flex justify-center items-center gap-2">
                <button id="left-btn" class="touch-button bg-gray-800 text-white rounded-full w-20 h-20 flex items-center justify-center border-2 border-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-arrow-left" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/></svg>
                </button>
                 <button id="down-btn" class="touch-button bg-gray-800 text-white rounded-full w-20 h-20 flex items-center justify-center border-2 border-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-arrow-down" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"/></svg>
                </button>
                <button id="right-btn" class="touch-button bg-gray-800 text-white rounded-full w-20 h-20 flex items-center justify-center border-2 border-gray-700">
                     <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-arrow-right" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/></svg>
                </button>
            </div>
        </div>

        <!-- Modal for Game Over / Pause -->
        <div id="modal" class="modal hidden">
            <div class="modal-content">
                <h2 id="modal-title" class="text-3xl mb-4">Game Over</h2>
                <p id="modal-text" class="mb-6">Press Space to play again!</p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('tetris');
            const context = canvas.getContext('2d');
            const nextCanvas = document.getElementById('next');
            const nextContext = nextCanvas.getContext('2d');

            const scoreElement = document.getElementById('score');
            const linesElement = document.getElementById('lines');
            const levelElement = document.getElementById('level');
            
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalText = document.getElementById('modal-text');

            const COLS = 10;
            const ROWS = 20;
            const BLOCK_SIZE = 24;
            const NEXT_BLOCK_SIZE = 24;

            context.canvas.width = COLS * BLOCK_SIZE;
            context.canvas.height = ROWS * BLOCK_SIZE;

            const COLORS = [
                null,
                '#FF0D72', // T
                '#0DC2FF', // I
                '#0DFF72', // O
                '#F538FF', // L
                '#FF8E0D', // J
                '#FFE138', // S
                '#3877FF', // Z
            ];

            const SHAPES = [
                [], // Empty
                [[1, 1, 1], [0, 1, 0]], // T
                [[2, 2, 2, 2]], // I
                [[3, 3], [3, 3]], // O
                [[4, 0, 0], [4, 4, 4]], // L
                [[0, 0, 5], [5, 5, 5]], // J
                [[0, 6, 6], [6, 6, 0]], // S
                [[7, 7, 0], [0, 7, 7]], // Z
            ];
            
            let board = createBoard();
            let score = 0;
            let lines = 0;
            let level = 1;
            let dropCounter = 0;
            let dropInterval = 1000;
            let lastTime = 0;
            let isPaused = false;
            let isGameOver = false;

            let player = {
                pos: { x: 0, y: 0 },
                matrix: null,
                score: 0,
            };

            let nextPieceIndex = null;
            
            function createBoard() {
                return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            }

            function createPiece(type) {
                return SHAPES[type];
            }

            function draw() {
                // Draw main board
                context.fillStyle = '#010409';
                context.fillRect(0, 0, canvas.width, canvas.height);
                drawMatrix(board, { x: 0, y: 0 }, context, BLOCK_SIZE);
                drawGhostPiece();
                drawMatrix(player.matrix, player.pos, context, BLOCK_SIZE);
                
                // Draw next piece
                nextContext.fillStyle = '#010409';
                nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
                if (nextPieceIndex) {
                    const matrix = SHAPES[nextPieceIndex];
                    if (matrix && matrix.length > 0 && matrix[0].length > 0) { // Safety check
                        const offset = {
                            x: (nextCanvas.width / NEXT_BLOCK_SIZE / 2) - (matrix[0].length / 2),
                            y: (nextCanvas.height / NEXT_BLOCK_SIZE / 2) - (matrix.length / 2)
                        };
                        drawMatrix(matrix, offset, nextContext, NEXT_BLOCK_SIZE);
                    }
                }
            }

            function drawMatrix(matrix, offset, ctx, blockSize, isGhost = false) {
                if (!matrix) return;
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            ctx.fillStyle = isGhost ? 'rgba(255, 255, 255, 0.2)' : COLORS[value];
                            ctx.fillRect((x + offset.x) * blockSize, (y + offset.y) * blockSize, blockSize, blockSize);
                            ctx.strokeStyle = isGhost ? 'rgba(255, 255, 255, 0.4)' : '#010409';
                            ctx.lineWidth = isGhost ? 1 : 2;
                            ctx.strokeRect((x + offset.x) * blockSize, (y + offset.y) * blockSize, blockSize, blockSize);
                        }
                    });
                });
            }

            function merge(board, player) {
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            board[y + player.pos.y][x + player.pos.x] = value;
                        }
                    });
                });
            }

            function collide(board, player) {
                const [m, o] = [player.matrix, player.pos];
                for (let y = 0; y < m.length; ++y) {
                    for (let x = 0; x < m[y].length; ++x) {
                        if (m[y][x] !== 0 &&
                           (board[y + o.y] &&
                            board[y + o.y][x + o.x]) !== 0) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function drawGhostPiece() {
                if (isPaused || isGameOver) return;
                const ghost = JSON.parse(JSON.stringify(player)); // Deep copy of the player piece
                while (!collide(board, ghost)) {
                    ghost.pos.y++;
                }
                ghost.pos.y--; // Back it up one step
                drawMatrix(ghost.matrix, ghost.pos, context, BLOCK_SIZE, true);
            }

            function rotate(matrix, dir) {
                const rotated = [];
                for (let i = 0; i < matrix[0].length; i++) {
                    rotated.push([]);
                }

                for (let y = 0; y < matrix.length; y++) {
                    for (let x = 0; x < matrix[y].length; x++) {
                        if (dir > 0) {
                             rotated[x][matrix.length - 1 - y] = matrix[y][x];
                        } else {
                            rotated[matrix[0].length - 1 - x][y] = matrix[y][x];
                        }
                    }
                }
                
                // This is a fix for some pieces that result in empty rows after rotation
                return rotated.filter(row => row.some(val => val !== undefined));
            }


            function playerRotate(dir) {
                const pos = player.pos.x;
                let offset = 1;
                let rotatedMatrix = rotate(player.matrix, dir);
                player.matrix = rotatedMatrix;

                while (collide(board, player)) {
                    player.pos.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > player.matrix[0].length) {
                        player.matrix = rotate(player.matrix, -dir); // revert
                        player.pos.x = pos;
                        return;
                    }
                }
            }
            
            function playerDrop() {
                player.pos.y++;
                if (collide(board, player)) {
                    player.pos.y--;
                    merge(board, player);
                    sweep();
                    playerReset();
                }
                dropCounter = 0;
            }
            
            function playerMove(dir) {
                player.pos.x += dir;
                if (collide(board, player)) {
                    player.pos.x -= dir;
                }
            }

            function playerHardDrop() {
                if (isPaused || isGameOver) return;
                while (!collide(board, player)) {
                    player.pos.y++;
                }
                player.pos.y--;
                merge(board, player);
                sweep();
                playerReset();
                dropCounter = 0;
            }

            function playerReset() {
                if (nextPieceIndex === null) {
                    nextPieceIndex = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
                }
                
                player.matrix = SHAPES[nextPieceIndex];
                nextPieceIndex = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;

                player.pos.y = 0;
                player.pos.x = (COLS / 2 | 0) - (player.matrix[0].length / 2 | 0);
                
                if (collide(board, player)) {
                    // Game Over
                    isGameOver = true;
                    showModal('Game Over', 'Press Space to play again!');
                }
            }
            
            function sweep() {
                let rowCount = 1;
                outer: for (let y = board.length - 1; y > 0; --y) {
                    for (let x = 0; x < board[y].length; ++x) {
                        if (board[y][x] === 0) {
                            continue outer;
                        }
                    }
                    const row = board.splice(y, 1)[0].fill(0);
                    board.unshift(row);
                    ++y;

                    lines++;
                    score += rowCount * 10;
                    rowCount *= 2;
                }
                updateScore();
            }

            function updateScore() {
                scoreElement.innerText = score;
                linesElement.innerText = lines;
                
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    levelElement.innerText = level;
                    dropInterval = 1000 / (level * 0.5 + 1); // Increase speed
                }
            }

            function update(time = 0) {
                if (isGameOver || isPaused) {
                    if(!isGameOver) requestAnimationFrame(update);
                    return;
                }
                
                const deltaTime = time - lastTime;
                lastTime = time;
                dropCounter += deltaTime;
                if (dropCounter > dropInterval) {
                    playerDrop();
                }

                draw();
                requestAnimationFrame(update);
            }
            
            function startGame() {
                board = createBoard();
                score = 0;
                lines = 0;
                level = 1;
                dropInterval = 1000;
                isGameOver = false;
                isPaused = false;
                hideModal();
                playerReset();
                updateScore();
                update();
            }

            function togglePause() {
                if (isGameOver) return;
                isPaused = !isPaused;
                if(isPaused) {
                    showModal('Paused', 'Press P to resume');
                } else {
                    hideModal();
                    update(); // Resume game loop
                }
            }
            
            function showModal(title, text) {
                modal.classList.remove('hidden');
                modalTitle.innerText = title;
                modalText.innerText = text;
            }

            function hideModal() {
                modal.classList.add('hidden');
            }


            document.addEventListener('keydown', event => {
                if (isGameOver) {
                    if (event.code === 'Space') {
                        startGame();
                    }
                    return;
                }

                // Don't allow moves if paused, except to unpause.
                if (isPaused && event.code !== 'KeyP') {
                    return;
                }
                
                switch(event.code) {
                    case 'ArrowLeft':
                        playerMove(-1);
                        break;
                    case 'ArrowRight':
                        playerMove(1);
                        break;
                    case 'ArrowDown':
                        playerDrop();
                        break;
                    case 'ArrowUp':
                        playerRotate(1);
                        break;
                    case 'Space':
                        event.preventDefault();
                        playerHardDrop();
                        break;
                    case 'KeyP':
                        togglePause();
                        break;
                }
            });

            // Touch controls
            document.getElementById('left-btn').addEventListener('click', () => playerMove(-1));
            document.getElementById('right-btn').addEventListener('click', () => playerMove(1));
            document.getElementById('down-btn').addEventListener('click', () => playerDrop());
            document.getElementById('rotate-btn').addEventListener('click', () => playerRotate(1));
            document.getElementById('drop-btn').addEventListener('click', () => playerHardDrop());
            
            startGame();
        });
    </script>
</body>
</html>



